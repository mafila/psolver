#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <inttypes.h>
#include <stdlib.h>
#include <sys/time.h>
#include <omp.h>

#define N_MAX_MOVES 255 // max solution moves (using uint8_t, 0 - zero moves, 255 - no moves)
#define N_MAX_MS_MOVES 31 // max move-set moves (+1 to store length)
#define N_MOVES_SPECIAL 16 // for each move store special moves like reverse, opposite, independent
#define MS_HASH_SIZE 0x80000000 // move-set hash size
#define MS_HASH_MASK (MS_HASH_SIZE-1) // and mask
#define MS_MAX_TABLE_SIZE 0x10000000 // max number of move-sets ~268 mln
#include "data.h" // generated by psolve.py

// Cube string and moves not allowed after previous move (3 maximum)
typedef struct { char c[N_BLOCKS]; uint8_t m0,m1,m2; } CUBE;

// Global variables for better performance & optimization
int step, inSeq, linkStep, linkSol, solutionFound // current step, sequence flag, linked step/solution, stop flag
,	maxDepth, maxWeight, bestWeight, newBestWeight // max search depth and weight, best weight values
,	bestSolLen, bestSolWeight, bestStep, bestStepSol // sequence of steps best values
,	nStepSol[N_STEPS]={0}, stepSolWeight[N_STEPS][N_MAX_SOL] // number of solutions and solutions weights
,	moveLen[N_STEPS]= {0}, nMoveLen= 0; // profile steps (sequence of steps) length
uint8_t *amoves0, *amoves1 // allowed moves for the current step and step's last move
,	stepSol[N_STEPS][N_MAX_SOL][N_MAX_MOVES+1] // list of solutions for the step
,	moveList[N_MAX_MOVES], nMoves= 0; // main list of moves
char revColor[256]= {}; // reverse colors (like F to B, U to D, R to L)
CUBE cube0; // start cube to solve


// Timer processing in milliseconds & screen printing functions
//
uint64_t solTimeStart= 0, stepTimeStart= 0, seqTimeStart= 0 // start time for step's solution, step and sequence
,	moveTime[N_STEPS]= {0}, logStartTimer= 0, logLastTimer= 0; // profile step time; log & progress times
char logbuf[1024]= {0}, stepTimeInfo[N_STEPS][256]= {{0}}; // string buffers for logger

static inline uint64_t timems() { // get time in milliseconds
	struct timeval time; gettimeofday(&time,NULL);
	return ((uint64_t)time.tv_sec*1000) + (time.tv_usec/1000);
}

static inline void printlog(char *fmt, ...) { // print at the beginning of line with time and arguments like printf
	va_list ap; va_start(ap, fmt); // variable arguments processing
	uint64_t t= timems();
	if (!logStartTimer) { logStartTimer= t; logLastTimer= 0; } // initialize timer
	vsprintf(logbuf, fmt, ap);
	if (t-logLastTimer>200 || fmt[strlen(fmt)-1]=='\n' || fmt[0]=='@') { // update after 200ms or has \n at the end
		int ms= t-logStartTimer, tm=ms/60/1000, ts=ms/1000%60, tms=ms%1000; // minutes, seconds and milliseconds
		printf("\33[2K\r%02d:%02d.%03d %s", tm, ts, tms, logbuf); // clear to the start of the line, show time
		logLastTimer= t;
	}
}

static inline void printprogress(char *fmt, ...) { // append progress status to saved logbuf string
	if (timems()-logLastTimer>200) // update after 200ms
		#pragma omp critical // outside critical logLastTimer can be changed by other thread
			if (timems()-logLastTimer>200) { va_list ap; va_start(ap, fmt); printlog(logbuf); vprintf(fmt, ap); }
}

static inline int timeLimTest(int softCond) { // test time limit for the step, softCond - soft timer condition flag
	uint64_t t= timems();
	if (stepTime[step] && t>stepTimeStart+stepTime[step]) { // step time is over
		#pragma omp critical
			if (!stepTimeInfo[step][0]) sprintf(stepTimeInfo[step], "STEP HARD timer stop\n");
		return 1;
	}
	if (solTime[step] && t>solTimeStart+solTime[step] && (solTimeHard[step] || softCond)) { // hard or soft limit
		#pragma omp critical
			if (!stepTimeInfo[step][0] && linkStep==-1)
				sprintf(stepTimeInfo[step], "SOLUTION %s timer stop\n", solTimeHard[step]?"HARD":"SOFT");
		return 1;
	}
	return 0;
}


// Operations with the cube - move, turn, check that it is solved, get weight and print it
//
char *moveNames[N_MOVES]= { // name of moves
	#include "movenames.h"
};

int moveSpecial[N_MOVES][N_MOVES_SPECIAL]= { // special moves reverse, skip1, skip2, opposite, reverse opposite, ...
	#include "specmoves.h"
};

static inline CUBE *moveCube(CUBE *Ca, CUBE *Cb, int move) { // move cube Ca to Cb with the move; set m0,m1,m2 for Cb
	char *a= Ca->c, *b= Cb->c;
	memcpy(b, a, N_BLOCKS);
	switch(move) {
		#include "moves.h"
	}
	return Cb;
}

static inline CUBE *turnCube(CUBE *Ca, CUBE *Cb, int turn) { // turn cube Ca to Cb with the turn
	char *a= Ca->c, *b= Cb->c;
	memcpy(b,a,N_BLOCKS);
	switch(turn) {
		#include "turns.h"
	}
	return Cb;
}

static inline void moveCubeSelf(CUBE *C, int move) { // move cube C to itself; m0,m1,m2 are not set
	CUBE C1;
	moveCube(C, &C1, move); memcpy(C->c, C1.c, N_BLOCKS);
}

static inline int isSolved(CUBE *pC) { // check if the cube is solved for the step
	char *a= pC->c;
	switch(step){
		#include "solved.h"
	}
	return 0;
}

static inline int cubeWeight(CUBE *pC) { // get cube's weight for the step
	char *a= pC->c;
	switch(step){
		#include "weight.h"
	}
	return 0;
}

void printCubeLine(CUBE *pC) { // print the cube string
	char *s= pC->c;
	if (!strcmp(ALG_NAME,"cube333gear")) { // cube 333 gear special processing
		int i, j, edges[24]= {1,3,5,7,37,39,41,43,10,12,14,16,19,21,23,25,46,48,50,52,28,30,32,34};
		for(i=0; i<=53; i++) {
			for(j=0; j<24; j++) if (edges[j]==i) { // en edge item
				if (s[100+i]) printf("%c'",s[100+i]);
				else if (s[200+i]) printf("%c\"",s[200+i]);
				else if (s[i]) printf("%c",s[i]);
				break;
			}
			if (j==24) printf("%c",s[i]); // not edge - center or corner
		}
		printf("\n");
	}
	else printf("%.*s\n", N_BLOCKS, s);
}

void printCube(CUBE *pC) { // print the cube string and colored scheme for rubiks NxNxN
	printCubeLine(pC);
	char *s= pC->c, cStr[256][8]= {{0}};
	for(int i=0; i<256; i++) sprintf(cStr[i], "%c", (char)i);
	strcpy(cStr[(int)'r'], "\033[0;41m"); strcpy(cStr[(int)'g'], "\033[0;42m");
	strcpy(cStr[(int)'y'], "\033[0;103m"); strcpy(cStr[(int)'b'], "\033[0;44m");
	strcpy(cStr[(int)'o'], "\033[0;43m"); strcpy(cStr[(int)'w'], "\033[0;47m");
	int sz= 0;
	if (!strcmp(ALG_NAME,"cube555")) sz= 5;
	else if (!strcmp(ALG_NAME,"cube444")) sz= 4;
	else if (!strcmp(ALG_NAME,"cube333")) sz= 3;
	else if (!strcmp(ALG_NAME,"cube222")) sz= 2;
	if (sz>0)
		for(int i=0; i<sz*3; i++) {
			for(int j=0; j<sz*4;j ++) {
				int f=-1;
				if (i<sz && j/sz==1) f=4;
				else if (i>=sz*2 && j/sz==1) f=5;
				else if (j<sz && i/sz==1) f=3;
				else if (j>=sz && i/sz==1) f= (j-sz)/sz;
				if (j%sz==0) printf(" ");
				char c= s[ f*sz*sz + (i%sz*sz) + (j%sz) ];
				if (f>=0) printf("%s%s\033[0m", cStr[(int)c], "  ");
				else printf("  ");
			}
			printf("\n");
		}
}


// Prune table storage
// 1st dimension - prune table by index
// 2nd - array with hash as index and minimum number of moves as value
// using uint32_t instead of size_t, so maximum hash size is 32 bit
//
uint8_t **pruneTable;
uint32_t *pruneCnt;

static inline uint32_t hashFromMask(char *s0, int prunei) { // called from prune.h, useMask flag in .cr file
	int n; // string length (mask or full)
	char *s, s1[N_BLOCKS]; // pointer to the packed cube string; temporary buffer to store packed string
	uint32_t hash= 0;
	if ((n= nStepMasks[step][prunei])) { // mask is not empty - repack
		s= s1; for(int j=0; j<n; j++) s[j]= s0[ stepMasks[step][prunei][j] ];
	}else{ // mask is empty - use full cube length and string
		n= N_BLOCKS; s= s0;
	}
	for(int i=0; i<n; i++) hash= s[i] + hash*65599u; // fast hash function
	return hash & (stepPruneSize[step][prunei]-1); // use bit mask length defined .cr file
}

static inline uint32_t hashCube(CUBE *pC, int prunei) { // calc cube's hash for the step and prune table
	char *a= pC->c;
	switch(step) {
		#include "prune.h"
	}
	return 0;
}

static inline void addPruneTableValue(CUBE *pC, int depth) { // add depth value to the prune table
	for(int j=0; j<nStepPrunes[step]; j++) { // iterate steps' prune tables
		uint32_t p= hashCube(pC, j); // calculate prune hash value
		uint8_t pd= pruneTable[j][p]; // current table depth value
		if (!pd || depth<pd) // empty or better depth
			#pragma omp critical // re-check since could be changed by other threads
				if (!pruneTable[j][p] || depth<pruneTable[j][p]) { pruneTable[j][p]= depth; pruneCnt[j]++; }
		if (nStepPruneSymmetry[step][j]) { // use symmetry => add all possible turns
			CUBE C1;
			for(int i=0; i<N_TURNS; i++) {
				turnCube(pC, &C1, i);
				p= hashCube(&C1, j); pd= pruneTable[j][p];
				if (!pd || depth<pd) // empty or better depth
					#pragma omp critical // re-check since could be changed by other threads
						if (!pruneTable[j][p] || depth<pruneTable[j][p]) { pruneTable[j][p]= depth; pruneCnt[j]++; }
			}
		}
	}
}

void buildPruneNext(CUBE *pC, int depth) { // recursive iterations to build prune table till maxDepth
	CUBE C1;
	for(int i=1; i<=amoves0[0]; i++) { // all allowed moves
		int m= amoves0[i]; if (m!=pC->m0 && m!=pC->m1 && m!=pC->m2) { // the move is allowed
			moveCube(pC, &C1, m); addPruneTableValue(&C1, depth+1);
			if (depth<maxDepth) buildPruneNext(&C1, depth+1);
		}
	}
}

static inline void addStepSolution(CUBE *pC, uint8_t *mvList, int depth) { // add solution to the step
	int addSolution= 1, w= (maxWeight ? cubeWeight(pC) : -1);
	if (w>=0) { // max weight mode
		if (w>bestWeight) { bestWeight= w; solutionFound= (solutionFound || w>=maxWeight); } // better weight
		else addSolution= 0; // skip
	}
	if (addSolution) {
		int ind=1, sol= nStepSol[step];
		if (linkStep>=0) { // copy start of move list from linked step
			ind+= stepSol[linkStep][linkSol][0];
			memcpy(stepSol[step][sol]+1, stepSol[linkStep][linkSol]+1, ind-1);
		}
		memcpy(stepSol[step][sol]+ind, mvList, depth+1); // save the solution
		stepSol[step][sol][0]= ind+depth; stepSolWeight[step][sol]= w; // with length & weight
		if (linkStep==-1) { // in single step increase solutions counter till limit
			if (++nStepSol[step]==stepMaxSol[step]) solutionFound= 1;
		}
		else if (!maxWeight) solutionFound= 1; // in sequence mode finish after first solution
	}
}

void tryLayerNext(CUBE *pC, int depth, uint8_t *mvList) { // search layer iteration to maxDepth with depth
	CUBE C1;
	if (depth<maxDepth) // outer if like this works faster
		for(int i=1; i<=amoves0[0]; i++) { if (solutionFound) return; // all allowed moves stop when solution found
			uint8_t m= amoves0[i]; if (m!=pC->m0 && m!=pC->m1 && m!=pC->m2) { // the move is allowed
				moveCube(pC, &C1, mvList[depth]= m); // make & save the move
				int deep= depth<maxDepth-stepHashDepth[step]-1; // should go deeper flag
				if (!deep) {
					deep= 1;
					for(int j=0; j<nStepPrunes[step]; j++) { // iterate prune tables and check min depth
						uint8_t pd= pruneTable[j][ hashCube(&C1, j) ];
						if (!pd || depth+pd>maxDepth) { deep= 0; break; }
					}
				}
				if (deep) tryLayerNext(&C1, depth+1, mvList); // go to the next layer
			}
		}
	else // on the last layer check if the cube could be solved
		for(int i=1; i<=amoves1[0]; i++) { if (solutionFound) return; // all allowed moves stop when solution found
			uint8_t m= amoves1[i]; if (m!=pC->m0 && m!=pC->m1 && m!=pC->m2) { // the move is allowed
				moveCube(pC, &C1, mvList[depth]= m); // make & save the move
				if (isSolved( &C1 )) // we have the solution !!! => save it
					#pragma omp critical
						addStepSolution(&C1, mvList, depth);
			}
		}
}

int pruneTableMain(CUBE *pC, int buildPrune) { // start the search or build prune table, use omp parallel
	int showPercentCounter= 0;
	solutionFound= 0;
	if (maxDepth>1) { // 2 and more layers
		uint8_t *fmoves= buildPrune ? amoves1 : amoves0; // in building mode use last move as first one
		#pragma omp parallel for schedule(dynamic,1) collapse(2) // expand two first moves
			for(int i1=1; i1<=fmoves[0]; i1++) for(int i2=1; i2<=amoves0[0]; i2++) { if (solutionFound) continue;
				int tlcond= linkStep==-1 ? nStepSol[step] : stepSol[step][nStepSol[step]][0]<N_MAX_MOVES;
				if (!buildPrune && timeLimTest(tlcond)) { solutionFound= 1; continue; } // stop conditions
				printprogress("%.1lf%%", 100.0 * ++showPercentCounter / fmoves[0] / amoves0[0]);
				uint8_t mvList[N_MAX_MOVES]; // move list array for each thread
				uint8_t m1= fmoves[i1]; CUBE C1; moveCube(pC, &C1, mvList[0]= m1); // make & save move1
				if (buildPrune) addPruneTableValue(&C1, 1); // build for 1st move
				uint8_t m2= amoves0[i2]; if (m2!=C1.m0 && m2!=C1.m1 && m2!=C1.m2) { // move2 could be done after move1
					CUBE C2; moveCube(&C1, &C2, mvList[1]= m2); // make & save move2
					if (buildPrune) { addPruneTableValue(&C2, 1); buildPruneNext(&C2, 2); } // build prune table
					else tryLayerNext(&C2, 2, mvList); // start the search
				}
			}
	}else{ // 0 or 1 layer
		uint8_t mvList[N_MAX_MOVES];
		if (buildPrune) buildPruneNext(pC, 0); // build prune table
		else tryLayerNext(pC, 0, mvList); // start the search
	}
	printprogress("100%%");
	return solutionFound;
}

void initPrune() { // initialize prune table - prepare memory and try to read from cache
	if (stepHashDepth[step] && nStepPrunes[step]) {
		char fn[N_MAX_PRUNES][256], buf[256], buf2[32];
		pruneTable= calloc(nStepPrunes[step], sizeof(uint8_t*));
		pruneCnt= calloc(nStepPrunes[step], sizeof(uint32_t));
		if (!pruneTable || !pruneCnt) { printf("initPrune. Not enough memory\n"); exit(-1); }
		for(int i=0; i<nStepPrunes[step]; i++) {
			pruneTable[i]= calloc(stepPruneSize[step][i], sizeof(uint8_t));
			if (!pruneTable[i]) { printf("initPrune. Not enough memory\n"); exit(-1); }
		}

		int fileFail= 0;
		for(int i=0; i<nStepPrunes[step]; i++) {
			sprintf(fn[i], "data/%s.%s", ALG_NAME, stepMd5[step][i]);
			FILE *f= fopen(fn[i],"r");
			if (f) {
				uint32_t p=0; uint8_t n=0;
				while( fread_unlocked(&p,sizeof(uint32_t),1,f) && fread_unlocked(&n,sizeof(uint8_t),1,f) ) {
					pruneTable[i][p]= n; pruneCnt[i]++;
				}
				fclose(f);
			}
			else fileFail= 1;
		}

		if (fileFail) { // if no cache file => build and save prune table from zero cube
			maxDepth= stepHashDepth[step];
			CUBE zero= { m0:-1, m1:-1, m2:-1 }; memcpy(zero.c,ZERO_CUBE,strlen(ZERO_CUBE));
			printlog("building prune tables "); logLastTimer= 0; pruneTableMain(&zero, 1);
			for(int i=0; i<nStepPrunes[step]; i++) { // write prune table to cache, binary format for faster reading
				FILE *f= fopen(fn[i],"w");
				for(uint32_t j=0; j<stepPruneSize[step][i]; j++) if (pruneTable[i][j]) {
					fwrite(&j, sizeof(uint32_t), 1, f); fwrite(&pruneTable[i][j], sizeof(uint8_t), 1, f);
				}
				fclose(f);
			}
			stepTimeStart= timems(); // restart step timer
		}

		*buf= 0;
		for(int i=0; i<nStepPrunes[step]; i++) {
			float sz= stepPruneSize[step][i]/1048576.0, pr= 100.0*pruneCnt[i]/stepPruneSize[step][i];
			sprintf(buf2, " | %.1fmb/%.2f%%", sz, pr); strcat(buf, buf2);
		}
		printlog("nPruneTables=%d depth=%d%s\n", nStepPrunes[step], stepHashDepth[step], buf);
	}
}

void doPruneStep(CUBE *pC) { // search with prune tables
	char stepStr[16]; linkStep>=0 ? sprintf(stepStr, "%d=>%d", step, linkStep) : sprintf(stepStr, "%d", step);
	printlog("STEP %s PRUNE TABLE SEARCH%s timeLim=%dms/%s,%dms/step nMoves=%d/%d depth=%d-%d maxSol=%d\n",
		stepStr, (maxWeight ? " + WEIGHT" : ""), solTime[step], solTimeHard[step]?"hard":"soft", stepTime[step],
		amoves0[0], amoves1[0], stepStartDepth[step], stepMaxDepth[step], stepMaxSol[step]);
	initPrune();

	int nSol= stepMaxSol[step], solNum= -1;
	if (linkStep==-1) { // Single step
		solTimeStart= timems(); bestWeight= -1; nStepSol[step]= 0;
		for(maxDepth= stepStartDepth[step]; maxDepth<stepMaxDepth[step]; maxDepth++) {
			if (bestWeight>=0) printlog("bestWeight=%d trying %d moves ", bestWeight, maxDepth+1);
			else printlog("trying %d moves ", maxDepth+1);
			pruneTableMain(pC, 0); // run prune table search
			if (timeLimTest(nStepSol[step])) break; // solution time limit
			if (solutionFound || nStepSol[step]==stepMaxSol[step]) break; // search is finished OR solutions limit
		}
	}else{ // Linked step
		if (stepMaxSol[step]==1 || stepMaxSol[step]>nStepSol[linkStep]) nSol= stepMaxSol[step]= nStepSol[linkStep];
		else if (stepMaxSol[step]==-1) nSol= 1;
		nStepSol[step]= 0; // in linked step use one record for the best solution
		if (stepLinkLocal[step]) bestSolLen= -1;
		for(solNum= 0; solNum<nSol && !timeLimTest(0); solNum++) {
			if (nSol>1) linkSol= nStepSol[linkStep]/nSol*solNum;
			else if (stepMaxSol[step]==-1) linkSol= nStepSol[linkStep]-1;
			else linkSol= solNum;
			CUBE C1= *pC; C1.m0= C1.m1= C1.m2= -1;
			if (stepSol[linkStep][linkSol][0]==N_MAX_MOVES) continue; // no solution in linked step
			for(int i=1; i<=stepSol[linkStep][linkSol][0]; i++) // update cube to the linkStep/linkSol position
				moveCubeSelf(&C1, stepSol[linkStep][linkSol][i]);

			stepSol[step][nStepSol[step]][0]= N_MAX_MOVES; // means no solution

			int endDepth= (bestSolLen>=0 && !maxWeight) ? // adjust depth if searching better solution length
				bestSolLen-stepSol[linkStep][linkSol][0]-1 : stepMaxDepth[step];
			solTimeStart= timems(); bestWeight= -1;
			for(maxDepth= stepStartDepth[step]; maxDepth<endDepth && !timeLimTest(bestSolLen>=0); maxDepth++) {
				printlog("solution %d/%d: trying %d moves ", solNum+1, nSol, maxDepth+1);
				if (pruneTableMain(&C1, 0)) break; // run prune table search
			}

			// Update bestSolLen, bestSolWeight, bestStep & bestStepSol for the sequence of steps
			int newSolW= stepSolWeight[step][ nStepSol[step] ],
				newSolL= stepSol[step][ nStepSol[step] ][0]<N_MAX_SOL ? stepSol[step][ nStepSol[step] ][0] : -1;
			if (maxWeight) { // max weight mode
				if (bestSolLen==-1 || newSolW>bestSolWeight || (newSolW==bestSolWeight && newSolL<bestSolLen)) {
					bestSolLen= newSolL; bestSolWeight= newSolW; bestStep= step; bestStepSol= nStepSol[step];
					printlog("solution #%d=>%d: weight=%d, moves=%d\n", solNum, linkSol, newSolW, newSolL);
				}
			}else{ // minimum length mode
				if ((bestSolLen==-1 || newSolL<bestSolLen) && stepSol[step][nStepSol[step]][0]<N_MAX_MOVES) {
					bestSolLen= newSolL; bestSolWeight= newSolW; bestStep= step; bestStepSol= nStepSol[step];
					printlog("solution #%d=>%d: moves=%d\n", solNum, linkSol, stepSol[bestStep][bestStepSol][0]);
				}
			}
			if (stepSol[step][nStepSol[step]][0]!=N_MAX_MOVES) nStepSol[step]++; // increment if has a solution
		}
	}
	if (stepTimeInfo[step][0]) printlog(stepTimeInfo[step]); // show time limit info if happened

	// show step results
	char sMoves[256]= {0}, sWeight[256]= {0}, resText[256]= {0};
	int minM= N_MAX_MOVES, maxM= 0, minW= stepSolWeight[step][0], maxW= minW, cnt= nStepSol[step];
	for(int i=0; i<cnt; i++) {
		if (stepSol[step][i][0]<minM) minM= stepSol[step][i][0];
		if (stepSol[step][i][0]>maxM) maxM= stepSol[step][i][0];
		if (stepSolWeight[step][i]<minW) minW= stepSolWeight[step][i];
		if (stepSolWeight[step][i]>maxW) maxW= stepSolWeight[step][i];
	}
	if (cnt) {
		if (minM==maxM) sprintf(sMoves, ", %d moves", minM); else sprintf(sMoves, ", %d-%d moves", minM, maxM);
		if (maxWeight) sprintf(sWeight, " width weight %d-%d", minW, maxW);
		sprintf(resText, "%d solution%s found%s%s", cnt, cnt>1?"s":"", sMoves, sWeight);
	}else
		sprintf(resText, "no solution");
	linkStep==-1 ? printlog("%s\n",resText) : printlog("linked solutions tested %d/%d, %s\n", solNum, nSol, resText);

	if (stepHashDepth[step] && nStepPrunes[step]) { // free memory for hash list table or prune table
		for(int i=0; i<nStepPrunes[step]; i++) free(pruneTable[i]);
		free(pruneTable); free(pruneCnt);
	}
}


// The Trick: try to add 1-2-3-4 moves to current moveList, keep solved state and try to increase weight
//
int bestWTmoves[4], bestWTpos[4], bestWTlen, bestWTweight; // weight trick data structures

//void weightTrickCheck(CUBE *pC, int wtLen, int *wtMoves, int *wtPos, int ind, int *pd, int *dd) {
void weightTrickCheck(CUBE *pC, int wtLen, int *wtMoves, int *wtPos, int ind, int *pd, int *dd) {
	CUBE C= *pC;
	for(int p= (ind>0 ? wtPos[ind-1] : 0); p<wtPos[ind]; p++) moveCubeSelf(&C, moveList[p]);
	moveCubeSelf(&C, wtMoves[ind]);
	if (ind==wtLen-1) {
		for(int p=wtPos[ind]; p<nMoves; p++) moveCubeSelf(&C, moveList[p]);
		if (isSolved( &C )) {
			int w= cubeWeight( &C );
			#pragma omp critical
				if (w>bestWTweight && (float)wtLen/(w-bestWTweight) <= stepParams[step][4]) {
					for(int j=0; j<wtLen; j++) { bestWTpos[j]= wtPos[j]; bestWTmoves[j]= wtMoves[j]; }
					bestWTweight= w; bestWTlen= wtLen;
				}
		}
	}else
		for(wtPos[ind+1]= wtPos[ind]+pd[ind]; wtPos[ind+1]<nMoves && wtPos[ind+1]<wtPos[ind]+dd[ind]; wtPos[ind+1]++) 
			weightTrickCheck(&C, wtLen, wtMoves, wtPos, ind+1, pd, dd);
}

void doWeightTrick(CUBE *pC) {
	int par= (int)stepParams[step][3];
	uint8_t *am= stepMoves[step][0][0];
	bestWTweight= cubeWeight(pC);
	while(1) {
		bestWTlen= -1;
		if (par  & 1) { // one move flag
			#pragma omp parallel for schedule(dynamic,1) collapse(2)
				for(int m= 1; m<=am[0]; m++) for(int p= 0; p<nMoves; p++) {
					int wtMoves[1]= { m }, wtPos[1]= { p };
					weightTrickCheck(&cube0, 1, wtMoves, wtPos, 0, NULL, NULL);
				}
		}
		if (par & 2) { // two moves flag
			int dd[1]= { stepParams[step][5] }; // ddX - max distance between moves
			#pragma omp parallel for schedule(dynamic,1) collapse(2)
				for(int m0i=1; m0i<=am[0]; m0i++) for(int m1i=0; m1i<=am[0]; m1i++) {
					int m0= am[m0i], m1= am[m1i]
					,	p1d= ( m1==m0 || m1==moveSpecial[m0][0] || m1==moveSpecial[m0][2] )
					,	pd[1]= { p1d }, wtMoves[2]= { m0, m1 }, wtPos[2];
					for(wtPos[0]= 0; wtPos[0]<nMoves; wtPos[0]++)
						weightTrickCheck(&cube0, 2, wtMoves, wtPos, 0, pd, dd);
				}
		}
		if (par & 4) { // three moves flag
			int dd[2]= { stepParams[step][6], stepParams[step][7] }; // ddX - max distance between moves
			#pragma omp parallel for schedule(dynamic,1) collapse(2)
				for(int m0i= 1; m0i<=am[0]; m0i++) for(int m1i=1; m1i<=am[0]; m1i++) {
					int m0= am[m0i], m1= am[m1i], m2= moveSpecial[m0][0]
					,	p1d= ( m1==m0 || m1==moveSpecial[m0][0] || m1==moveSpecial[m0][2] )
					,	p2d= ( m2==m1 || m2==moveSpecial[m1][0] || m2==moveSpecial[m1][2] )
					,	pd[2]= { p1d, p2d }, wtMoves[3]= { m0, m1, m2 }, wtPos[3];
					for(wtPos[0]= 0; wtPos[0]<nMoves; wtPos[0]++)
						weightTrickCheck(&cube0, 3, wtMoves, wtPos, 0, pd, dd);
				}
			dd[0]= stepParams[step][8]; dd[1]= stepParams[step][9];
			#pragma omp parallel for schedule(dynamic,1) collapse(2)
				for(int m0i= 1; m0i<=am[0]; m0i++) for(int m2i=1; m2i<=am[0]; m2i++) {
					int m0= am[m0i], m1= moveSpecial[m0][0], m2= am[m2i], p1d= 1
					,	p2d= ( m2==m1 || m2==moveSpecial[m1][0] || m2==moveSpecial[m1][2] )
					,	pd[2]= { p1d, p2d }, wtMoves[3]= { m0, m1, m2 }, wtPos[3];
					for(wtPos[0]= 0; wtPos[0]<nMoves; wtPos[0]++) 
						weightTrickCheck(&cube0, 3, wtMoves, wtPos, 0, pd, dd);
				}
		}
		if (par & 8) { // four moves flag
			int dd[3]= { stepParams[step][10], stepParams[step][11], stepParams[step][12] };
			#pragma omp parallel for schedule(dynamic,1) collapse(2)
				for(int m0i= 1; m0i<=am[0]; m0i++) for(int m1i=1; m1i<=am[0]; m1i++) {
					int m0= am[m0i], m1= am[m1i], m2= moveSpecial[m1][0], m3= moveSpecial[m0][0]
					,	p1d= ( m1==m0 || m1==moveSpecial[m0][0] || m1==moveSpecial[m0][2] ), p2d= 1
					,	p3d= ( m3==m2 || m3==moveSpecial[m2][0] || m3==moveSpecial[m2][2] )
					,	pd[3]= { p1d, p2d, p3d }, wtMoves[4]= { m0, m1, m2, m3 }, wtPos[4];
					for(wtPos[0]= 0; wtPos[0]<nMoves; wtPos[0]++)
						weightTrickCheck(&cube0, 4, wtMoves, wtPos, 0, pd, dd);
				}
			dd[0]= stepParams[step][13]; dd[1]= stepParams[step][14]; dd[2]= stepParams[step][15];
			#pragma omp parallel for schedule(dynamic,1) collapse(2)
				for(int m0i= 1; m0i<=am[0]; m0i++) for(int m1i=1; m1i<=am[0]; m1i++) {
					int m0= am[m0i], m1= am[m1i], m2= moveSpecial[m0][0], m3= moveSpecial[m1][0]
					,	p1d= ( m1==m0 || m1==moveSpecial[m0][0] || m1==moveSpecial[m0][2] )
					,	p2d= ( m2==m1 || m2==moveSpecial[m1][0] || m2==moveSpecial[m1][2] )
					,	p3d= ( m3==m2 || m3==moveSpecial[m2][0] || m3==moveSpecial[m2][2] )
					,	pd[3]= { p1d, p2d, p3d }, wtMoves[4]= { m0, m1, m2, m3 }, wtPos[4];
					for(wtPos[0]= 0; wtPos[0]<nMoves; wtPos[0]++)
						weightTrickCheck(&cube0, 4, wtMoves, wtPos, 0, pd, dd);
				}
		}
		if (bestWTlen>=0) {
			int moveListNew[N_MAX_MOVES], nMovesPrev= nMoves; nMoves= 0;
			for(int i=0; i<nMovesPrev; i++) {
				for(int j=0; j<bestWTlen; j++) if (i==bestWTpos[j]) moveListNew[nMoves++]= bestWTmoves[j];
				moveListNew[nMoves++]= moveList[i];
			}
			for(int i=0; i<nMoves; i++) moveList[i]=moveListNew[i];
		}
		else break;
	}
	*pC= cube0; for(int i=0; i<nMoves; i++) moveCubeSelf(pC,moveList[i]);
}


// Weight iterations
// msTable - move-sets table block size is msTableBlock, first byte is the number of moves
// msTransTable - transformation table for the regular move-sets
// msLastChance - like msTable but build from templates and used without transformations
// msHash - hash table, used to avoid same cube position with different move-sets, collisions possible
//
uint8_t *msTable, *msTransTable, *msLastChance, *msHash;
int msTableLen, msTableBlock, msLastChanceLen, msLastChanceBlock // tables lengths and block sizes
,	nStack, stackSize, stack[N_MAX_SOL][N_MAX_MOVES+1]; // stack of solutions for weight step
float moveWeight, solMoveWeight[N_MAX_SOL], stackMoveWeight[N_MAX_SOL]; // weights current, solution's and stack's

static inline uint32_t msHashCube(CUBE *pC) {
	uint32_t hash= 0;
	for(int i=0; i<N_BLOCKS; i++) hash= pC->c[i] + hash*65599u;
	return (hash & MS_HASH_MASK);
}

static inline void buildMsAddMoveList(CUBE *pC, int len, uint8_t *mvList, int useLastChance) {
	CUBE C1, C2, C3;
	uint32_t hash= msHashCube(pC);
	#pragma omp critical
		if (!msHash[hash]) {
			msHash[hash]= 1;
			int smLen= stepMoves[step][0][0][0]; // use 'soft' moves (move-set index 0)
			if (maxDepth<stepMaxDepth[step]-1) for(int i1=1; i1<=smLen; i1++) {
				msHash[ msHashCube( moveCube(pC, &C1, stepMoves[step][0][0][i1]) ) ]= 1;
				if (maxDepth<stepMaxDepth[step]-2) for(int i2=1; i2<=smLen; i2++) {
					msHash[ msHashCube( moveCube(&C1, &C2, stepMoves[step][0][0][i2]) ) ]= 1;
					if (maxDepth<stepMaxDepth[step]-3) for(int i3=1; i3<=smLen; i3++)
						msHash[ msHashCube( moveCube(&C2, &C3, stepMoves[step][0][0][i2]) ) ]= 1;
				}
			}
			if (useLastChance) {
				if (msLastChanceLen==MS_MAX_TABLE_SIZE) { printf("Increase MS_MAX_TABLE_SIZE\n"); exit(-1); }
				msLastChance[ msLastChanceLen*msLastChanceBlock ]= len;
				memcpy( msLastChance + msLastChanceLen*msLastChanceBlock + 1, mvList, len);
				msLastChanceLen++;
			}else{
				if (msTableLen==MS_MAX_TABLE_SIZE) { printf("Increase MS_MAX_TABLE_SIZE\n"); exit(-1); }
				msTable[ msTableLen*msTableBlock ]= len;
				memcpy( msTable + msTableLen*msTableBlock + 1, mvList, len);
				msTableLen++;
			}
		}
}

static inline int processTmpMove(uint8_t *ms, uint8_t *mvList) { // process templates moves
	switch(*ms){
		case 255: return mvList[ *(ms+1) ]; // '='' same move
		case 254: return moveSpecial[ mvList[*(ms+1)] ][0]; // '^' reverse move
		case 253: return moveSpecial[ mvList[*(ms+1)] ][4]; // '$' opposite move
		case 252: return moveSpecial[ mvList[*(ms+1)] ][5]; // '#' reverse opposite move
	}
	return *ms;
}

// build move-set template iteration
void buildTmpMsNext(CUBE *pC, int depth, uint8_t *mvList, uint8_t mv[N_MAX_MS_MOVES][N_MOVES+1], int useLastChance) {
	CUBE C1;
	for(int i=1; i<=mv[depth][0]; i++) {
		int m= processTmpMove( mv[depth]+i, mvList );
		if (m!=pC->m0 && m!=pC->m1 && m!=pC->m2) {
			moveCube(pC, &C1, mvList[depth]= m);
			if (depth<maxDepth) buildTmpMsNext(&C1, depth+1, mvList, mv, useLastChance);
			else if (isSolved(&C1)) buildMsAddMoveList(&C1, depth+1, mvList, useLastChance); // last move
		}
	}
}

void buildMsNext(CUBE *pC, int depth, uint8_t *mvList) { // build move-set iteration
	CUBE C1;
	if (depth<maxDepth)
		for(int m=0; m<N_MOVES; m++) { // use all moves
			if (m!=pC->m0 && m!=pC->m1 && m!=pC->m2) {
				moveCube(pC, &C1, mvList[depth]= m);
				buildMsNext(&C1, depth+1, mvList);
			}
		}
	else // last move
		for(int i=1; i<=stepMoves[step][0][1][0]; i++) { // use 'hard' moves (index 1)
			int m= stepMoves[step][0][1][i];
			if (m!=pC->m0 && m!=pC->m1 && m!=pC->m2) {
				moveCube(pC, &C1, mvList[depth]= m);
				if (isSolved(&C1) && cubeWeight(&C1)!=bestWeight) buildMsAddMoveList(&C1, depth+1, mvList, 0);
			}
		}
}

void buildMs(char *fn) { // build move-set, use file name to write it out
	printlog("building move-sets "); logLastTimer= 0;
	msTableLen= msLastChanceLen= msLastChanceBlock= 0;
	msTableBlock= stepMaxDepth[step]+1;
	for(int msi= 1; msi<1+stepParams[step][2]; msi++) // find max length for template move-sets
		if (stepMoveSetsLen[step][msi]>=msTableBlock) msTableBlock= stepMoveSetsLen[step][msi]+1;
	for(int msi= 1+stepParams[step][2]; msi<nStepMoveSets[step]; msi++) // find max length for last chance move-sets
		if (stepMoveSetsLen[step][msi]>=msLastChanceBlock) msLastChanceBlock= stepMoveSetsLen[step][msi]+1;

	msHash= calloc( MS_HASH_SIZE, sizeof(uint8_t) );
	msTable= calloc( MS_MAX_TABLE_SIZE, msTableBlock );
	msLastChance= calloc( MS_MAX_TABLE_SIZE, msLastChanceBlock );
	if (!msHash || !msTable || !msLastChance) { printf("buildMs. Not enough memory\n"); exit(-1); }

	CUBE zero= { m0:-1, m1:-1, m2:-1 }; memcpy(zero.c, ZERO_CUBE, N_BLOCKS); // start with zero cube
	bestWeight= cubeWeight(&zero); // should be max_weight
	int startDepth= stepStartDepth[step]-1; if (startDepth<3) startDepth= 3; // move-sets makes sense from 3 moves
	for(maxDepth=startDepth; maxDepth<stepMaxDepth[step]; maxDepth++) {
		int percentCnt= 0;
		#pragma omp parallel for schedule(dynamic,1) collapse(2) // expand two first moves
			for(int m1=0; m1<N_MOVES; m1++) for(int m2=0; m2<N_MOVES; m2++) {
				printprogress("depth=%d len=%d %.1lf%%", maxDepth+1, msTableLen, 100.0* ++percentCnt/N_MOVES/N_MOVES );
				uint8_t mvList[N_MAX_MS_MOVES]; // move list array for each thread
				CUBE C1; moveCube(&zero, &C1, mvList[0]= m1); // make move 1
				if (m2!=C1.m0 && m2!=C1.m1 && m2!=C1.m2) { // move 2 could be done after move 1
					CUBE C2; moveCube(&C1, &C2, mvList[1]= m2); // make move 2
					buildMsNext(&C2, 2, mvList);
				}
			}
	}
	memset(msHash, 0, MS_HASH_SIZE);
	for(int msi= 1; msi<1+stepParams[step][2]; msi++) if ((maxDepth= stepMoveSetsLen[step][msi]-1)>=2) { // 3+ moves
		int percentCnt= 0, nMoves1= stepMoves[step][msi][0][0], nMoves2= stepMoves[step][msi][1][0];
		#pragma omp parallel for schedule(dynamic,1) collapse(2) // expand two first moves from template
			for(int i1=1; i1<=nMoves1; i1++) for(int i2=1; i2<=nMoves2; i2++) {
				printprogress("set=%d len=%d %.1lf%%", msi, msLastChanceLen, 100.0* ++percentCnt/nMoves1/nMoves2 );
				int m1= stepMoves[step][msi][0][i1], m2= stepMoves[step][msi][1][i2];
				uint8_t mvList[N_MAX_MOVES]; // move list array for each thread
				CUBE C1; moveCube(&zero, &C1, mvList[0]= m1); // make move 1
				if (m2!=C1.m0 && m2!=C1.m1 && m2!=C1.m2) { // move 2 could be done after move 1
					CUBE C2; moveCube(&C1, &C2, mvList[1]= m2); // make move 2
					buildTmpMsNext(&C2, 2, mvList, stepMoves[step][msi], 0);
				}
			}
	}
	memset(msHash, 0, MS_HASH_SIZE);
	for(int msi= 1+stepParams[step][2]; msi<nStepMoveSets[step]; msi++)
		if ((maxDepth= stepMoveSetsLen[step][msi]-1)>=2) { // from 3 moves
			int percentCnt= 0, nMoves1= stepMoves[step][msi][0][0], nMoves2= stepMoves[step][msi][1][0];
			#pragma omp parallel for schedule(dynamic,1) collapse(2) // expand two first moves from template
				for(int i1=1; i1<=nMoves1; i1++) for(int i2=1; i2<=nMoves2; i2++) {
					printprogress("set=%d len=%d %.1lf%%", msi, msLastChanceLen, 100.0* ++percentCnt/nMoves1/nMoves2 );
					int m1= stepMoves[step][msi][0][i1], m2= stepMoves[step][msi][1][i2];
					uint8_t mvList[N_MAX_MOVES]; // move list array for each thread
					CUBE C1; moveCube(&zero, &C1, mvList[0]= m1); // make move 1
					if (m2!=C1.m0 && m2!=C1.m1 && m2!=C1.m2) { // move 2 could be done after move 1
						CUBE C2; moveCube(&C1, &C2, mvList[1]= m2); // make move 2
						buildTmpMsNext(&C2, 2, mvList, stepMoves[step][msi], 1);
					}
				}
		}

	FILE *f= fopen(fn, "w"); // write out move-sets
	fwrite(&msTableLen, sizeof(int), 1, f); fwrite(&msTableBlock, sizeof(int), 1, f);
	fwrite(&msLastChanceLen, sizeof(int), 1, f); fwrite(&msLastChanceBlock, sizeof(int), 1, f);
	fwrite(msTable, msTableBlock, msTableLen, f); fwrite(msLastChance, msLastChanceBlock, msLastChanceLen, f);
	fclose(f);
	free(msHash);
	stepTimeStart= timems(); // restart step timer
}

void initMs(int cw) { // initialize move-sets and template move-sets storage
	char fn[256]; sprintf(fn, "data/%s.%s", ALG_NAME, stepMd5[step][0]);
	int fileFail= 1; msTable= msLastChance= NULL;
	FILE *f= fopen(fn, "r");
	if (f) {
		int cnt= 0;
		cnt+= fread_unlocked(&msTableLen, sizeof(int), 1, f);
		cnt+= fread_unlocked(&msTableBlock, sizeof(int), 1, f);
		cnt+= fread_unlocked(&msLastChanceLen, sizeof(int), 1, f);
		cnt+= fread_unlocked(&msLastChanceBlock, sizeof(int), 1, f);
		if (cnt==4) {
			msTable= calloc( msTableLen, msTableBlock );
			msLastChance= calloc( msLastChanceLen, msLastChanceBlock );
			if (!msTable || !msLastChance) { printf("initMs. Not enough memory\n"); exit(-1); }
			if ((fread_unlocked(msTable, msTableBlock, msTableLen, f)==msTableLen) &&
				(fread_unlocked(msLastChance, msLastChanceBlock, msLastChanceLen, f)==msLastChanceLen)) fileFail= 0;
			else { free(msTable); free(msLastChance); }
		}
		fclose(f);
	}
	if (fileFail) buildMs(fn);
	printlog("moveSets=%d building transformations...", msTableLen);
	msTransTable= calloc( msTableLen, N_BLOCKS );
	if (!msTransTable) { printf("initMs. Not enough memory\n"); exit(-1); }

	CUBE C0= { m0:-1, m1:-1, m2:-1 }; for(int j=0; j<N_BLOCKS; j++) C0.c[j]= j;
	#pragma omp parallel for schedule(dynamic,1024) collapse(1)
		for(int i=0; i<msTableLen; i++) {
			CUBE C= C0;
			for(int j=1; j<=msTable[ i*msTableBlock ]; j++) moveCubeSelf(&C, msTable[ i*msTableBlock + j ]);
			for(int j=0; j<N_BLOCKS; j++) msTransTable[ i*N_BLOCKS + j ]= C.c[ j ];
		}

	char winfo[1024]= {0}; if (linkStep==-1) sprintf(winfo, "startWeight=%d ", cw);
	printlog("%stargetWeight=%d moveSets=%d lastChance=%d\n", winfo, maxWeight, msTableLen, msLastChanceLen);
}

static inline void addWeightSol(int pos, uint8_t *ms, float mw) { // pos=0 to last position, pos=-1 replace worst
	static int solPosIterator= -1; // global sol position iterator to vary the position
	int solPos= -1; // local position pointer
	if (nStepSol[step]==stepMaxSol[step]) { // no space in sol list
		if (pos) { // find worst position excluding last one with static iterator to vary the position
			for(int i=0; i<nStepSol[step]-1; i++) {
				if (++solPosIterator >= nStepSol[step]-1) solPosIterator= 0;
				if (solMoveWeight[solPosIterator] >= mw) { solPos= solPosIterator; break; }
			}
		}else{ // find worst position with maximum moveWeight
			float maxW= solMoveWeight[solPos= 0];
			for(int i=1; i<nStepSol[step]; i++) if (solMoveWeight[i]>maxW) maxW= solMoveWeight[solPos= i];
			for(int i=solPos+1; i<nStepSol[step]; i++) { // move solutions list up from solPos till end
				solMoveWeight[i-1]= solMoveWeight[i];
				memcpy(stepSol[step][i-1], stepSol[step][i], stepSol[step][i][0]+1);
			}
			solPos= nStepSol[step]-1;
		}
	}else{ // have space for new solution
		solPos= nStepSol[step]++; // increment solutions size and set to last position
		if (pos) { // keep last element and set pointer to last-1
			solMoveWeight[solPos]= solMoveWeight[solPos-1];
			memcpy(stepSol[step][solPos], stepSol[step][solPos-1], stepSol[step][solPos-1][0]+1);
			solPos--;
		}
	}
	if (solPos>=0) { solMoveWeight[solPos]= mw; memcpy(stepSol[step][solPos], ms, ms[0]+1); } // add new solution
}

static inline void checkMoveSet(CUBE *pC, uint8_t *ms) { // check if the move-set brings to better weight
	int w= cubeWeight(pC);
	if (w>bestWeight)
		#pragma omp critical
		{
			float mw= (float)*ms/(w-bestWeight);
			if (mw <= moveWeight) { // better moveWeight => add to single position in stepSol
				moveWeight= mw; newBestWeight= w;
				addWeightSol(0, ms, mw);
				if (w==maxWeight) solutionFound= 1; // target achieved
			}
			else if (mw <= stepParams[step][0]) addWeightSol(-1, ms, mw);
		}
}

static inline void checkMoveSets(CUBE *pC, int maxLen) { // check move-sets with msTransTable
	int w= cubeWeight(pC);
	bestWeight= newBestWeight= w; moveWeight= 1e9; nStepSol[step]= 0; solutionFound= 0;
	#pragma omp parallel for schedule(dynamic,1024) collapse(1)
		for(int msi=0; msi<msTableLen; msi++) if (!solutionFound && msTable[ msi*msTableBlock ]<maxLen) {
			CUBE C= *pC;
			for(int i=0; i<N_BLOCKS; i++) C.c[i]= pC->c[ msTransTable[ msi*N_BLOCKS + i] ]; // apply transformation
			checkMoveSet(&C, msTable + msi*msTableBlock);
		}
}

static inline void checkLastChance(CUBE *pC, int maxLen) { // check templated move-sets aka last chance
	int w= cubeWeight(pC);
	bestWeight= newBestWeight= w; moveWeight= 1e9; nStepSol[step]= 0; solutionFound= 0;
	#pragma omp parallel for schedule(dynamic,1024) collapse(1)
		for(int msi=0; msi<msLastChanceLen; msi++) if (!solutionFound) {
			int len= msLastChance[ msi*msLastChanceBlock ];
			if (len<maxLen) { // limit with maximum achieved length 
				CUBE C= *pC;
				for(int i=1; i<=len; i++) moveCubeSelf(&C, msLastChance[ msi*msLastChanceBlock + i ]);
				checkMoveSet(&C, msLastChance + msi*msLastChanceBlock);
			}
		}
}

static inline void addSolToStack(int sol, float mw) { // add a solution with index sol and provided moveWeight
	int stackPos= nStack;
	if (nStack==stepMaxSol[step]) { // no space in stack
		for(int i=0; i<nStack; i++)
			if (mw < stackMoveWeight[i]) { stackPos= i; break; } // set stackPos to worst position
	}
	else nStack++; // have space => increment stack size counter

	if (stackPos<nStack) { // add solution to the stack if possible
		stackMoveWeight[stackPos]= mw;
		for(int j=0; j<=stepSol[step][sol][0]; j++) stack[stackPos][j]= stepSol[step][sol][j];
	}
}

void doWeightStep(CUBE *pC) { // perform weight step for the cube, use GLOBAL step variable
	char stepStr[16]; sprintf(stepStr, linkStep>=0?"%d=>%d":"%d", step, linkStep);
	printlog("STEP %s WEIGHT_ITERATIONS timeLim=%dms/%s,%dms/step\n",
		stepStr, solTime[step], solTimeHard[step]?"hard":"soft", stepTime[step]);
	int	bestLen= -1, bestMoves[N_MAX_MOVES], beforeMoves[N_MAX_MOVES], nBeforeMoves= nMoves
	,	cw= cubeWeight(pC), maxReached= cw==maxWeight;
	for(int i=0; i<nMoves; i++) beforeMoves[i]= moveList[i];
	initMs(cw);

	// solS, solE - start and end solution indexes for linked step, solI - increment +1 or -1, wsD - solutions limit
	int solS= 0, solE= linkStep>=0 ? nStepSol[linkStep]-1 : 0, solI= 1, wsD= stepParams[step][1];
	if (wsD) { solS= nStepSol[linkStep]-1; solE= nStepSol[linkStep]>wsD ? nStepSol[linkStep]-wsD : 0; solI= -1; }
	int sol= solS;
	while(!timeLimTest(0)) { // sol is linked solutions from solS to solE iterate while inside time limit
		nStack= 1; stack[0][0]= stackMoveWeight[0]= nStepSol[step]= 0; // first empty solution in the stack to start

		CUBE C1= cube0; C1.m0= C1.m1= C1.m2= -1; nMoves= 0; // start with the very start cube
		for(int i=0; i<nBeforeMoves; i++) moveCubeSelf(&C1, moveList[nMoves++]= beforeMoves[i]); // to step position
		if (linkStep>=0) for(int i=1; i<=stepSol[linkStep][sol][0]; i++) // to linkStep/sol position
				moveCubeSelf(&C1, moveList[nMoves++]= stepSol[linkStep][sol][i]);
		cw= cubeWeight(&C1); doWeightTrick(&C1); // do the trick for each solution, change moveList
		int nMoves1= nMoves;

		solTimeStart= timems();
		for(int cnt=0; nStack && !timeLimTest(maxReached); cnt++) { // stack is not empty & time is not over
			int item= nStack-1; float mw= stackMoveWeight[item]; // find smallest, start from stack end
			for(int i=nStack-2; i>=0; i--) if (stackMoveWeight[i]<mw) { mw= stackMoveWeight[i]; item= i; }
			CUBE cube=C1; nMoves= nMoves1; // update cube to stack position
			for(int i=1; i<=stack[item][0]; i++) moveCubeSelf(&cube, moveList[nMoves++]= stack[item][i]);
			for(int i= item; i<nStack-1; i++) { // remove item from the stack
				stackMoveWeight[i]= stackMoveWeight[i+1];
				for(int j=0; j<=stack[i][0]; j++) stack[i][j]= stack[i+1][j];
			}
			nStack--; // remove position from stack

			int lastChance= 0, iter= 0; solutionFound= cubeWeight(&cube)==stepMaxWeights[step];
			while(!solutionFound) {
				printlog("sol %d*%d/%d*%d, w=%d-%d-%d: ", sol, cnt, nStack, iter, cw, bestWTweight, cubeWeight(&cube));
				int maxLen= maxReached ? bestLen-nMoves : N_MAX_MOVES; // max is reached => limit search
				lastChance ? checkLastChance(&cube, maxLen) : checkMoveSets(&cube, maxLen);
				if (nStepSol[step]) { // solutions found
					for(int sol=0; sol<nStepSol[step]-1; sol++) // add inside limit solutions to the stack
						if (solMoveWeight[sol] <= stepParams[step][0]) addSolToStack(sol, mw+solMoveWeight[sol]);
					for(int i=1; i<=stepSol[step][ nStepSol[step]-1 ][0]; i++) // move cube to the iteration solution
						moveCubeSelf(&cube, moveList[nMoves++]= stepSol[step][ nStepSol[step]-1 ][i]);
					iter++;
				}
				else if (!lastChance) lastChance=1; else break; // no solutions => use last chance or break
			}

			if ( (solutionFound || (!maxReached && !solutionFound)) // max is reached once => keep the status
				&& (bestLen==-1 || nMoves<bestLen || (!maxReached && solutionFound)) ) {
					if (!maxReached && solutionFound) maxReached= 1;
					bestLen=nMoves; for(int i=0; i<bestLen; i++) bestMoves[i]= moveList[i];
					printlog("sol %d*%d/%d*%d: w=%d-%d-%d moves=%d%s\n",
						sol, cnt, nStack, iter, cw, bestWTweight, cubeWeight(&cube), nMoves, maxReached?"(+)":"(-)");
			}
		}
		if (sol==solE) break; // solS=>solE done, or increment
		sol+= solI;
	}

	bestStep= step; nStepSol[step]= 1; bestStepSol= 0; bestSolLen= stepSol[step][0][0]= bestLen;
	for(int i=0; i<bestLen; i++) stepSol[step][0][i+1]= bestMoves[i];
	*pC= cube0; nMoves= 0;
	printlog("weight step done, target %s in %d moves\n", maxReached?"achieved!":"missed:(", bestLen);
	free(msTable); free(msLastChance);
}


int main(int argc,char *argv[]) {
	setbuf(stdout, NULL); // no buffering to pipe with python subprocess
	remove(".solution"); // remove solution file
	char s[1024]= {0}; // concatenate command line arguments to s
	for(int i=1; i<argc; i++) if (strlen(s)+strlen(argv[i])<1024) strcat(s, argv[i]);

	// Generate random cube
	CUBE cube= { m0:-1, m1:-1, m2:-1 };
	if (!memcmp(s,"rand",4)) {
		srand( timems() ); // initialize random generator
		memcpy(cube.c, ZERO_CUBE, strlen(ZERO_CUBE)); // start with zero cube
		for(int i=0; i<100+rand()%1000; i++) {
			turnCube(&cube, &cube0, rand()%N_TURNS); memcpy(cube.c,cube0.c,N_BLOCKS);
		}
		for(int i=0; i<10000+rand()%100000; i++) moveCubeSelf(&cube, rand()%N_MOVES);
		for(int i=0; i<2; i++) moveCubeSelf(&cube, rand()%N_MOVES);
		if (!strcmp(ALG_NAME,"cube333gear")) { // 333g only => make all edges fit cube position
			while(!cube.c[1]) moveCubeSelf(&cube, 0);
			while(!cube.c[5]) moveCubeSelf(&cube, 2);
			while(!cube.c[41]) moveCubeSelf(&cube, 4);
		}
		printCubeLine(&cube);
		return 0;
	}

	// Check cube string length
	if (strlen(s)!=strlen(ZERO_CUBE) && (strcmp(ALG_NAME,"cube333gear")||strlen(s)!=54)) {
		printf("Incorrect argument. Wrong number of blocks\n"); return -1;
	}

	// Cube to solve, save it for final check with all the moves
	memcpy(cube.c, s, N_BLOCKS); cube0= cube;

	// Prepare reverse colors
	#if defined REVCOL_FROM && defined REVCOL_TO
		for(int i=0; i<256; i++) revColor[i]= i;
		for(int i=0; i<strlen(REVCOL_FROM); i++) revColor[(int)REVCOL_FROM[i]]= REVCOL_TO[i];
	#endif

	// Algo steps
	int prevStepEmpty= 0;
	for(step=0; step<N_STEPS; step++) {
		stepTimeStart= timems(); printf("\n");
		linkStep= stepLink[step]; maxWeight= stepMaxWeights[step]; amoves0= stepMoves[step][0][0]; // set GLOBALs
		amoves1= (stepMoveSetsLen[step][0]>1 ? stepMoves[step][0][1] : amoves0); // final step moves

		if (!prevStepEmpty && !inSeq) printCube(&cube); // show cube to solve
		if (stepSeq[step]==1) { bestSolLen= bestSolWeight= -1; inSeq= 1; seqTimeStart= stepTimeStart; } // start seq
		else if (stepSeq[step]>1) { // join previous stepSeq[step] steps
			nStepSol[step]= stepSeq[step];
			char joinStr[256], *s= joinStr;
			for(int ps=step-stepSeq[step], n=0; ps<step; ps++,n++) {
				memcpy(stepSol[step][n], stepSol[ps][nStepSol[ps]-1], stepSol[ps][nStepSol[ps]-1][0]+1);
				s+= n ? sprintf(s, ",%d", ps) : sprintf(s, "%d", ps);
			}
			printlog("STEP %d: join solutions from steps %s\n", step, joinStr);
			continue;
		}

		// The cube is not solved or max weight not achieved or have solutions in linked step
		if ((!isSolved(&cube) || (maxWeight && cubeWeight(&cube)<maxWeight)) && (linkStep==-1 || nStepSol[linkStep])) {
			if (maxWeight && !nStepPrunes[step]) doWeightStep(&cube); // run weight step
			else doPruneStep(&cube); // run prune table search step
			prevStepEmpty= 0;
		}else{ // the cube is solved for the step or nothing to check
			if (linkStep>=0 && !nStepSol[linkStep])
				printlog("STEP %d=>%d nothing to check from linked step\n", step, linkStep);
			else{
				printlog("STEP %d is solved\n", step);
				if (inSeq) { nStepSol[step]= 1; stepSol[step][0][0]= 0; } // add zero solution for next steps
			}
			prevStepEmpty= 1;
		}

		// Analyze & process step results
		int nMoves0= nMoves; moveLen[nMoveLen]= 0; // zero moves profile by default
		if (!inSeq) { // non sequence step
			if (nStepSol[step]>0) { // add moves from last solution to moveList
				int lastSol= nStepSol[step]-1;
				for(int i=1; i<=stepSol[step][lastSol][0]; i++) moveList[nMoves++]= stepSol[step][lastSol][i];
				moveLen[nMoveLen]= stepSol[step][lastSol][0]; // profile moves
			}
			moveTime[nMoveLen++]= timems()-stepTimeStart; // save step time profile
		}else if (inSeq && stepSeq[step]==-1) { // last step in sequence
			inSeq= 0;
			if (bestSolLen>=0) { // add moves from bestStep/bestStepSol to moveList
				for(int i=1; i<=stepSol[bestStep][bestStepSol][0]; i++)
					moveList[nMoves++]= stepSol[bestStep][bestStepSol][i];
				moveLen[nMoveLen]= stepSol[bestStep][bestStepSol][0]; // profile moves
			}
			moveTime[nMoveLen++]= timems()-seqTimeStart; // save seq time profile
		}
		for(int i=nMoves0; i<nMoves; i++) moveCubeSelf(&cube, moveList[i]);
	}

	// Try to optimize the cube by removing and replacing some moves defined in .cr file
	int nMoves0= nMoves, moveListOpt[N_MAX_MOVES], isOpt= 0;
	printf("\nOptimizing...\n");
	while(1) {
		int i=0, j, nMovesOpt= 0;
		while( i<nMoves-1 ) {
			int m1= moveList[i], m2= moveList[i+1]; char *mn1= moveNames[m1], *mn2= moveNames[m2];
			if ( moveSpecial[m1][0]==m2) { printf("\t%s-%s=skip at %d\n", mn1, mn2, i+1); i+=2; isOpt=1; }
			else if (moveSpecial[m1][1]==m2) {
				int m= moveSpecial[m1][2]; moveListOpt[nMovesOpt++]= m; isOpt=1;
				printf("\t%s+%s=%s at %d\n", mn1, mn2, moveNames[m], i+1); i+=2;
			}else if (moveSpecial[m1][2]==m2) {
				int m= moveSpecial[m1][3]; moveListOpt[nMovesOpt++]= m; isOpt=1;
				printf("\t%s+%s=%s at %d\n", mn1, mn2, moveNames[m], i+1); i+=2;
			}else{
				for(j=4; j<N_MOVES_SPECIAL; j++) if (moveSpecial[m1][j]==m2) break;
				if (j<N_MOVES_SPECIAL && i<nMoves-2) {
					int m3= moveList[i+2]; char *mn3= moveNames[m3];
					if (moveSpecial[m1][0]==m3) {
						printf("\t%s-%s-%s=%s at %d\n", mn1, mn2, mn3, mn2, i+1);
						moveListOpt[nMovesOpt++]=m2; i+=3; isOpt=1;
					}else if (moveSpecial[m1][1]==m3) {
						int m= moveSpecial[m1][2]; moveListOpt[nMovesOpt++]= m; moveListOpt[nMovesOpt++]= m2; isOpt=1;
						printf("\t%s+%s+%s=%s+%s at %d\n", mn1, mn2, mn3, moveNames[m], mn2, i+1); i+=3;
					}else if (moveSpecial[m1][2]==m3) {
						int m= moveSpecial[m1][3]; moveListOpt[nMovesOpt++]= m; moveListOpt[nMovesOpt++]= m2; isOpt=1;
						printf("\treplace %s+%s+%s=%s+%s at %d\n", mn1, mn2, mn3, moveNames[m], mn2, i+1); i+=3;
					}else{ moveListOpt[nMovesOpt++]= m1; i++; }
				}else{ moveListOpt[nMovesOpt++]= m1; i++; }
			}
		}
		if (i<nMoves) moveListOpt[nMovesOpt++]= moveList[i];
		if (nMoves==nMovesOpt) break;
		for(int i=0; i<nMovesOpt; i++) moveList[i]=moveListOpt[i];
		nMoves= nMovesOpt;
	}
	if (!isOpt) printf("\tnothing to optimize\n"); else printf("\n");

	// Show the solution and write out .solution file
	FILE *f= fopen(".solution","w"); printf("\nSolution:\n");
	for(int i=0; i<nMoves; i++) {
		moveCubeSelf(&cube0, moveList[i]);
		printf("*%d:%d\t%s\t", i+1, moveList[i], moveNames[moveList[i]]);
		printCubeLine( &cube0 );
		fprintf(f, "%s%d", (i ? " " : ""), moveList[i]);
	}
	fclose(f);

	// Last check - is the cube solved for the last step
	step=N_STEPS-1; if (isSolved(&cube0)) {
		printCube(&cube0);
		printf("moveLen=%d,%d", nMoves, nMoves0-nMoves); for(int i=0; i<nMoveLen; i++) printf(",%d", moveLen[i]);
		printf("\nmoveTime=0,0"); for(int i=0; i<nMoveLen; i++) printf(",%ld", moveTime[i]);
		printf("\n");
	}else printf("FUCK!!! moveLen=0\n"); // something goes wrong

	return 0;
}